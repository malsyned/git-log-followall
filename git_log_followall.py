import subprocess
import sys
import os
import argparse
import itertools
from pathlib import Path
from concurrent.futures import ThreadPoolExecutor

def git_log_follow_all(git_options, pathspecs):
    histories = git_get_histories(pathspecs)
    try:
        all_commits, all_past_pathspecs = histories
    except ValueError:
        return None

    return git_selective_log(git_options, all_commits, all_past_pathspecs)

def git_get_histories(pathspecs):
    pool = ThreadPoolExecutor()
    results = pool.map(git_pathspec_history, git_pathspecs_trees(pathspecs))
    return pairs_of_iters_to_pair_of_iters(results)

def git_pathspecs_trees(pathspecs):
    return flatten(git_ls_files(pathspec) for pathspec in pathspecs)

def git_ls_files(pathspec):
    output = run_get_stdout(['git', 'ls-files',
                             '-z',
                             '--', pathspec])
    paths = list(filter(None, output.split(b'\0')))
    return paths or [pathspec]

def git_pathspec_history(pathspec):
    commits = []
    pathspec_past_paths = [pathspec]

    # Entries are <hash> \n <statusblob> \0\0
    # where <statusblob> is a sequence of \0-terminated fields
    output = run_get_stdout(['git', 'log',
                             '--follow', '--name-status',
                             '--pretty=format:%x00%x00%H', '-z',
                             '--', pathspec])
    records = filter(None, output.split(b'\0\0'))
    for record in records:
        commit, statusblob = record.split(b'\n', 1)
        commits.append(commit)

        for status_line in parse_statusblob(statusblob):
            try:
                status, from_, to = status_line
            except ValueError:
                pass
            else:
                if (status_is_name_change(status)
                    and to == pathspec_past_paths[-1]):
                    pathspec_past_paths.append(from_)
    return commits, pathspec_past_paths

def parse_statusblob(statusblob):
    # Parses status entries generated by this code from git diff.c:
    # if (p->status == DIFF_STATUS_COPIED ||
    #     p->status == DIFF_STATUS_RENAMED) {
    #         /* ... */
    #         write_name_quoted(name_a, opt->file, inter_name_termination);
    #         write_name_quoted(name_b, opt->file, line_termination);
    # } else {
    #         /* ... */
    #         write_name_quoted(name_a, opt->file, line_termination);
    # }

    fields = list(filter(None, statusblob.split(b'\0')))
    i = 0
    while i < len(fields):
        if status_is_name_change(fields[i]):
            chunk = 3
        else:
            chunk = 2
        yield fields[i:i+chunk]
        i += chunk

def status_is_name_change(status):
    return status.startswith(b'R') or status.startswith(b'C')

WINERROR_FNAME_TOO_LONG = 206

def git_selective_log(git_options, commits, pathspecs):
    """Show git log for all commits, but only for pathspecs"""
    try:
        result = subprocess.run(['git', 'log',
                                 '--stdin', '--ignore-missing']
                                 + git_options
                                 + ['--'] + list(pathspecs),
                                input=b'\n'.join(commits))
    except FileNotFoundError as ex:
        if hasattr(ex, 'winerror') and ex.winerror == WINERROR_FNAME_TOO_LONG:
            raise PathLengthError from ex
        else:
            raise
    return result.returncode

class PathLengthError(FileNotFoundError):
    pass

def run_get_stdout(*args, **kwargs):
    result = subprocess.run(*args, check=True, capture_output=True, **kwargs)
    return result.stdout

def pairs_of_iters_to_pair_of_iters(i):
    return map(flatten, zip(*i))

def flatten(iter_):
    return itertools.chain.from_iterable(iter_)

def main():
    git_options, pathspecs = parse_cmdline(sys.argv[1:])
    program = Path(sys.argv[0]).name
    try:
        result = git_log_follow_all(git_options, pathspecs)
        if result is None and sys.stderr.isatty():
            print('nothing to do.', file=sys.stderr)
        exit(result)
    except subprocess.CalledProcessError as ex:
        # A git plumbing call failed
        cmd = ' '.join(map(os.fsdecode, ex.cmd))
        print(f'{program}: {cmd}', file=sys.stderr)
        if ex.stderr:
            print(os.fsdecode(ex.stderr), file=sys.stderr)
        exit(ex.returncode)
    except PathLengthError as ex:
        print(f'{program}: git log command line too long. Try a smaller set of paths.',
              file=sys.stderr)
        exit(ex.__cause__.errno)

def parse_cmdline(argv):
    # On the use of os.fsencode: It's important that the file names be
    # byte strings, since they will be compared against byte strings
    # retrieved from git's stdout
    try:
        double_dash = argv.index('--')
    except ValueError:
        # Try our best to separate pathspecs from other arguments
        parser = argparse.ArgumentParser()
        parser.add_argument('pathspec', nargs='*', type=os.fsencode)
        args, git_options = parser.parse_known_args(argv)
        pathspecs = args.pathspec
    else:
        # pathspecs are separated from other arguments by --
        git_options = argv[:double_dash]
        pathspecs = list(map(os.fsencode, argv[double_dash + 1:]))
    return git_options, pathspecs

if __name__ == '__main__':
    main()
